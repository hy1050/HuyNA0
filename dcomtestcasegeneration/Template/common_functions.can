/*@!Encoding:1250*/
//!****************************************************************************************
//! Copyright(c) - This program/software is the exclusive property of Robert Bosch
//! Gmbh. Without their consent it may not be reproduced or given to third parties.
//!****************************************************************************************

/*!
* \file common_functions.can
* \brief	Contains all commonly used functions.
*
* \authors Test engineers of CC_DA/EAV2-Bp.
*
* \par Module description
* 	Implements the functions and test cases commonly used in the CC_DA/EAV2-Bp group for MQB-B and PQ project test automation.
*
*/

///@cond
variables
 {  ///@endcond
	
	//- - 
	//! \brief  Global variable to set bus context for correct CAN channel usage.
	//! 
	//! \type int type variable
	//- -
    int     g_debug = 0;
	
	//- - 
	//! \brief  Global variable stores the size of the transmitted message
	//! 
	//! \type int type variable
	//- -
    int     ByteSize;
	
	//- - 
	//! \brief  Global variable stores the service ID of the diagnostic message
	//! 
	//! \type int type variable
	//- -	
    int     SID;

	//- - 
	//! \brief  Global variable to store the value of a signal so it could be restored later.
	//! 
	//! \type int type variable
	//- -
    int     StoredSignalValue;

	//- - 
	//! \brief  Global variable stores the arrived response bytes in string variable
	//! 
	//! \type char array type variable
	//- -
    char    byteString[8194];
    
	//- - 
	//! \brief  Global variable to save the previously received response
	//! 
	//! \type char array type variable
	//- -
	char    seedString[8194];

	//- - 
	//! \brief  Global variable to store the actual coding of the ECU
	//! 
	//! \type char array type variable
	//- -
	char    codeString[52];
	
	//- - 
	//! \brief  Global variable to save the previously received response in byte format
	//! 
	//! \type byte array type variable
	//- -
    byte    seedData[8194];
	
	//-
	//! \brief  Global variable to store a timestamp. \n
	//!			E.g., this is used in the <em> <b> TimeNowStart </b> </em> testcase.
	//! 
	//! \type Float type variable.
	//-

	float   tMesStart;
	
	//- - 
	//! \brief  Global variable to save the count of received message bytes
	//! 
	//! \type long type variable
	//- -	
	long    ResponseLength = 0;
    
	//- - 
	//! \brief  Global variable for the transmitted message
	//! 
	//! \type byte array type variable
	//- -		
    byte    RqTxData[8194];
	
	//- - 
	//! \brief  Global variable to store the actual transmitted message in string type
	//! 
	//! \type char array type variable
	//- -	
    char    RqTxStringData[8194];
	
	//- - 
	//! \brief  Global variable for the received message
	//! 
	//! \type byte array type variable
	//- -	
    byte    RsRxIntData[8194];
	
	//- - 
	//! \brief  Global variable to store the actual received message in string type
	//! 
	//! \type char array type variable
	//- -	
    char    RsRxStringData[8194];
    
	//- - 
	//! \brief  Global variable to handle to switch within the TP Rx routines
	//! 
	//! \type long type variable
	//- -		
    long routineHandle = 0;
	
	//- - 
	//! \brief  Global variable to display the actual Data block
	//! 
	//! \type char array type variable
	//- -		
    char g_TextEvent[12];

	/// @cond
	msTimer t20ms;
    msTimer t10ms;/// @endcond
	
///@cond
}///@endcond

/// @cond
on preStart
{
    dword BusContext;
    int stMinTime;
    int blockSize;
    int rxId;
    int txId;

    /* Set Bus context for correct CAN channel usage */
    if (1 == g_debug)
    {
        BusContext = GetBusContext();
        write("BusContext pre set = %x",BusContext); //Debugmsg   
    }
    SetBusContext(0x10001); //Set CAN channel
    CanOnline(3); //reset CAN
    BusContext = GetBusContext(); //Read CAN bus channel context
    write("BusContext set = %x",BusContext);

    stMinTime = 0x14;
    blockSize = 0x08;
    rxId = 0x73B;
    txId = 0x733;

    SysSetVariableString(sysvar::Diag::SessionID, "0xFF");
    SysSetVariableString(sysvar::Diag::Data, "0xFF");
    SysSetVariableString(sysvar::Diag::ServiceID, "0xFF");
    SysSetVariableString(sysvar::Diag::LocalID, "0xFFFF");

    /* Init */
    OSEKTL_SetTxId(txId);
    OSEKTL_SetRxId(rxId);
    OSEKTL_SetSTMIN(stMinTime);
    OSEKTL_SetBS(blockSize);
    OSEKTL_SetNrmlMode();
    /****************/
}/// @endcond

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert char array to byte array
//!
//! \note	It is necessary to convert the char array to byte array before sending it out with the inside Vector function. \n
//!			This function converts the request string to a compatible byte array to send for the camera and calculates the byte size. \n
//!			This byte array is a global variable.
//!
//! \param  char convertable_array is the request diagnostic character string
//!
//! \note	The parameter character string should contain only numbers and lowercase letters.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void CharArray2Byte(char convertable_array[])
{
    int i;
    char c1,c2;
    int strIndex;
    
    strIndex = 0;
    
    for (i = 0; i < elcount(RqTxStringData); i++)
	{
		RqTxStringData[i] = 0;
	} 
   
    for (i = 0; i < elcount(convertable_array); i++)
    {
		RqTxStringData[i] = convertable_array[i];     //RqTxStringData is a global variable
    }

    ByteSize = 0;  //ByteSize is a global variable
    for (i = 0; i < (strlen(RqTxStringData)/2); i++)
    {
        strIndex = i * 2;  
        c1 = RqTxStringData[strIndex];
        c2 = RqTxStringData[strIndex + 1];
        RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);     // RqTxData is a global variable
        ByteSize++;
    }
    SID = RqTxData[0];
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to set the CAN transmit and receive message IDs.
//!
//! \note	This function can set the CanIDs for the transmission of messages.		
//!
//! \param  int rxId is the ID of the transmit messages in CAN.
//! \param  int txId is the ID of the receive messages in CAN.
//!
//! \note	The parameters should be hexadecimal values and compatible with normal addressing mode.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void setType(int rxId, int txId)
{
	//TODO: Check if the rxId an txId is a valid hex format
	//They will be from now the message IDs in CAN
	OSEKTL_SetTxId(txId);   
	OSEKTL_SetRxId(rxId);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to send message using functional addressing
//!
//! \note	Set the CANIDs to the functional addresses, after the request was sent, function set back the CANIDs to the physical addresses. \n
//! 		VW uses CanID 0x7CF for the transmit messages. \n
//! 		VW uses CanID 0x782 for the receive messages. \n
//!
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used to check the response.
//- -----------------------------------------------------------------------------------------------
testcase FunctionalMessage(char Request[], char Response[], char CompareMode[])
{
	setType (0x73B,0x7DF);
	//setType (0x73B,0x733);
	RequestResponseCompareLogic(Request, Response, CompareMode);
    //Reset the default CAN message IDs
    //setType (0x78A,0x782);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send diagnostic message and check the response
//!
//! \note	The function can send a string to the ECU from the parameter (Request) and check the received message (Response). \n
//! 		String to byte conversion is needed to send and receive the string parameters, the function also includes this feature.
//! 		
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used to check the response.
//!
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//!
//! \return The result of the response matching. If the expected response is received, the function returns with 1  \n
//!			and test step passed state, otherwise with 0 and test step failed state.
//- -----------------------------------------------------------------------------------------------
int RequestResponseCompareLogic(char Request[], char Response[], char CompareMode[])
{
    byte responsePending;
    long result;
    long timeOutValue;
    int numberRPs;
    
    responsePending = 0;
    numberRPs = 0;
    timeOutValue = 5000;
	//check the validity of the compare mode
    if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) 
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode)) || 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))))
	{
		TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
        TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
		return 0;
	}
	else
	{
		//The compare mode is valid
		CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
		//OSEKTL_ActivateAck(1);
		OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array
    
		setType (0x73B,0x733);
		//START check the response from the camera: 
		do
		{ 
			//Wait for the message from the camera
			responsePending = 0;
			if(ResponseLength < 1000)
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
			}
			else if(ResponseLength < 3000)
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*2);
			}
			else
			{
				result = TestWaitForTextEvent("TpMsgReceived", timeOutValue*3);
			}
			if(result == 0)
			{  
				//If no response is received
				return responseMatching(CompareMode, Response, numberRPs, "Noresponse", result);
			}
			else if(result == 1)
			{    
				//If response is received
				//Negative branch starts
				if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
				{ 
					if( RsRxIntData[2] == 0x78 )
					{
						TestStep("INFO","Response Pending received from ECU");
						responsePending = 1;
						numberRPs++;
						timeOutValue = 10000;
					}
					else
					{
						//TestStep("INFO","Negative Response from ECU!");
						return responseMatching(CompareMode, Response, numberRPs, "NRC", result);
					}
				}
				//Positive branch starts
				if( RsRxIntData[0] == (SID + 0x40) )  
				{
					//TestStep("INFO","Positive Response from ECU!");
					return responseMatching(CompareMode, Response, numberRPs, "response", result);
				}	
			}
		}while( (responsePending == 1) && (numberRPs < 24) );  //Pending response handling
	
		if( responsePending == 1 )
		{
			TestStepFail("INFO","Timeout while waiting for diag response!");
			return 0;
		}
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to check whether response received and the response match or not.
//!
//! 		
//! \param  char CompareMode is the compare mode should be used to check the response.
//! \param  char Response is the expected response.
//! \param  int NumberRPs is the count of the arrived response pendings.
//! \param  char MessageFormat identifies the response type. (Response or NRC)
//! \param  long Result identifies that response is received or not. (0 = not received, 1 = received)
//!
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//!
//! \return If the expected response is received, the function returns with 1 and test step passed state, otherwise with 0 and test step failed state.
//- -----------------------------------------------------------------------------------------------
int responseMatching(char CompareMode[], char Response[], int NumberRPs, char MessageFormat[], long Result)
{
	if(Result == 1)
	{
		TestStep("INFO","EXPECTED: %s", Response);
		TestStep("INFO","RECEIVED: %s", byteString);
		//Message received, Compare mode is equal
		if(0 == strncmp("Equal", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
			{
				TestStepPass("INFO","Expected %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is regexp
		else if(0 == strncmp("Regexp", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStepFail("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is not equal
		else if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)) || 0 == strncmp("NotEqual_Regexp", CompareMode, strlen(CompareMode)))
		{
			if(0 == strncmp("NotEqual", CompareMode, strlen(CompareMode)))
			{
				if(0 != strncmp(byteString, Response, strlen(Response)) || strlen(byteString) != strlen(Response))
				{
					TestStepPass("INFO","Not equal %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{      
					TestStepFail("INFO","Unexpected equal %s is received!", MessageFormat);
					return 0;
				}
			}
			else
			{
				if(0 == str_match_regex(byteString, Response))
				{
					TestStepPass("INFO","Wrong substring in %s received as expected!", MessageFormat);
					return 1;
				}
				else
				{
					TestStepFail("INFO","Unexpected %s with correct substring received!", MessageFormat);
					return 0;
				}
			}
		}
		//Message received, Compare mode is suppressed (equal or regexp)
		else if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(0 == strncmp("response", MessageFormat,strlen(MessageFormat)))
			{
				if(NumberRPs > 0)
				{
					if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
					{
						if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
						{
							TestStepPass("INFO","Expected %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","Unexpected %s received after response pending!", MessageFormat);
							return 0;
						}
					}
					else
					{
						if(1 == str_match_regex(byteString, Response))
						{
							TestStepPass("INFO","Expected substring in %s received after response pending!", MessageFormat);
							return 1;
						}
						else
						{
							TestStepFail("INFO","There is not expected substring after response pending in %s!", MessageFormat);
							return 0;
						}
					}
				}
				else
				{
					TestStepFail("INFO","Response received without response pending!");
					return 0;
				}
			}
			else
			{
				if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)))
				{
					if(0 == strncmp(byteString, Response, strlen(Response))&& strlen(byteString) == strlen(Response))
					{
						TestStepPass("INFO","Expected %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","Unexpected %s received!", MessageFormat);
						return 0;
					}
				}
				else
				{
					if(1 == str_match_regex(byteString, Response))
					{
						TestStepPass("INFO","Expected substring in %s received!", MessageFormat);
						return 1;
					}
					else
					{
						TestStepFail("INFO","There is not expected substring in %s!", MessageFormat);
						return 0;
					}
				}	
			}
		}
		//Message received, Compare mode is regexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{   
			if(1 == str_match_regex(byteString, Response))
			{
				TestStep("INFO","Expected substring in %s received!", MessageFormat);
				return 1;
			}
			else
			{
				TestStep("INFO","Unexpected %s or wrong substring received!", MessageFormat);
				return 0;
			}
		}
		//Message received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepFail("INFO","Response arrived but it was NOT expected!");
			return 0;
		}
	}
	else
	{
		//Message does not received, Compare mode is suppressed (equal or regexp)
		if(0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)))
		{
			if(NumberRPs == 0)
			{
				TestStepPass("INFO","No response pending and no response are received as expected!");
				return 1;
			}
			else
			{
				TestStepFail("INFO","No response is received after response pending!");
				return 0;
			}
		}
		//Message does not received, Compare mode is none
		else if(0 == strncmp("None", CompareMode,strlen(CompareMode)))
		{
			TestStepPass("INFO","Response did not arrive as expected!");
			return 1;
		}
		//Message does not received, Compare mode is RegexpNoFailed
		else if(0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode)))
		{
			TestStep("INFO","Response did not arrive.");
			return 0;
		}
		//Message does not received, Compare mode is not supported here
		else
		{
			TestStepFail("INFO","Timeout while waiting for diag response");
			return 0;
		}
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to save the previously received response to a global variable
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void saveResponse()
{
    int i;
    for (i=1; i<8194; i++)
    { 
        seedString[i] = byteString[i];
        seedData[i] =  RsRxIntData[i];
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to compare the previously saved seed with the actual.	
//!
//! \note	Preconditions: \n
//!			1. Request seed \n
//!			2. Save response \n
//!			3. Request seed again	
//!
//! \return 0 or 1. \n
//!			0: Seeds are different. \n
//!			1: Seeds are identical.
//- -----------------------------------------------------------------------------------------------
int compareSeedAlgo()
{
    int i, equal;
    equal = 0;
    for (i=4; i<12; i++)
    { 
        if (seedString[i] != byteString[i])
        {
            equal++;
        }
    }
    if (equal == 0)
    {   
        return 1;
    }
    else
    {
        return 0;
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send key to the camera based on the previously saved seed in the application.
//!
//! \note	The tester requests a seed from the ECU and uses it to calculate the key using a specified formula. \n
//! 		The calculation procedure is used for the key: Key = Seed + Pin. \n
//!			After the key calculation the function will send the key to the ECU and check the response.
//! 			
//! \param  char sendKey is the request to send the calculated key.
//! \param  char sendKeyResponse is the expected response should be awaited.
//! \param  dword Pin is used to identify the authentication.
//! \param  char CompareMode is the compare mode should be used to check the response for the sent key.
//!			
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void sendKeyAlgo(char sendKey[], char sendKeyResponse[], dword Pin, char CompareMode[])
{
	dword authKey;
	byte resultarray[6] = {0,0,0,0,0,0};

	resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
	resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);

	authKey = seedData[5] |
         (seedData[4] << 8) |
         (seedData[3] << 16) |
         (seedData[2] << 24);
    
	authKey = authKey + Pin;
      
	resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
    CreateByteString(resultarray, 0, elcount(resultarray));

    RequestResponseCompareLogic(byteString, sendKeyResponse, CompareMode);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send key to the camera based on the previously saved seed in the flash bootloader.
//!
//! \note	The tester requests a seed from the ECU and uses it to calculate the key using a specified formula. \n
//!			After the key calculation the function will send the key to the ECU and check the response.
//! 			
//! \param  char sendKey is the request to send the calculated key.
//! \param  char sendKeyResponse is the expected response should be awaited.
//! \param  dword REP_A_Key is used to define RBA_CBB_AKEY_VALUE
//! \param  dword REP_B_Key is used to define RBA_CBB_BKEY_VALUE
//! \param  dword REP_C_Key is used to define RBA_CBB_CKEY_VALUE
//! \param  dword REP_D_Key is used to define RBA_CBB_DKEY_VALUE
//!			
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void sendKeyAlgoREP(char sendKey[], char sendKeyResponse[], dword REP_A_Key, dword REP_B_Key, dword REP_C_Key, dword REP_D_Key)
{
    dword authKey;
    dword tempkey;
    dword keyLowValue, keyUpperValue;
    dword keyMaxValue = 0xFFFFFFFF; 
    int i;
    byte resultarray[6] = {0,0,0,0,0,0};

    resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
    resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);

    authKey = seedData[5] |
           (seedData[4] << 8) |
           (seedData[3] << 16) |
           (seedData[2] << 24);
               
    for(i = 0; i <7 ; i++)
    {
        tempkey = authKey ;
        authKey = authKey + REP_A_Key;

        if((keyMaxValue - REP_A_Key) < tempkey)
        {
        /* Rotate Right by 10 */
            keyLowValue = authKey & (0x000003FF);
            keyUpperValue = keyLowValue << 22;
            authKey = authKey >> 10;
            authKey = authKey | keyUpperValue;
            authKey = authKey ^ REP_B_Key;
        }
        else
        {
        /* Rotate Left by 13 */
            keyUpperValue = authKey & (0xFFF80000);
            keyLowValue   = keyUpperValue >> 19;
            authKey      = authKey << 13;
            authKey      = authKey | keyLowValue;
            authKey      = authKey ^ REP_C_Key;
        }
    }

    authKey = authKey - REP_D_Key;
        
    resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
    CreateByteString(resultarray, 0, elcount(resultarray));

    if(0 == strncmp("None", sendKeyResponse,strlen(sendKeyResponse)))
    {
        RequestResponseCompareLogic(byteString, "", "None");
    }
    else
    {
        RequestResponseCompareLogic(byteString, sendKeyResponse, "Equal");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to send key to the camera based on the previously saved seed in the plant mode.
//!
//! \note	The tester requests a seed from the ECU and uses it to calculate the key using a specified formula. \n
//!			After the key calculation the function will send the key to the ECU and check the response.
//! 			
//! \param  char sendKey is the request to send the calculated key.
//! \param  char sendKeyResponse is the expected response should be awaited.
//! \param  dword RBEOLPin is used to define RBEOL unique pin
//! \param  dword PMARequest is used to define the plant mode activation part2 request
//! \param  char CompareMode is the compare mode should be used to check the response for the sent key.
//!			
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void sendKeyAlgoRBEOL(char sendKey[], char sendKeyResponse[], dword RBEOLPin, dword PMARequest, char CompareMode[])
{
	dword authKey;
	byte resultarray[6] = {0,0,0,0,0,0};
      
	resultarray[0] = char2byte(sendKey[0], 16) + char2byte(sendKey[1], 1);
	resultarray[1] = char2byte(sendKey[2], 16) + char2byte(sendKey[3], 1);
      
	authKey = seedData[5] |
			(seedData[4] << 8) |
			(seedData[3] << 16) |
			(seedData[2] << 24);
               
	authKey = authKey & RBEOLPin; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
	authKey = authKey | PMARequest; //Plant mode activation part request
      
	resultarray[5] = (byte)(authKey & 0xff);
	resultarray[4] = (byte)((authKey >> 8) & 0xff);
	resultarray[3] = (byte)((authKey >> 16) & 0xff);
	resultarray[2] = (byte)((authKey >> 24) & 0xff);
      
	CreateByteString(resultarray, 0, elcount(resultarray));

	RequestResponseCompareLogic(byteString, sendKeyResponse, CompareMode);
}


//- -----------------------------------------------------------------------------------------------
//! \brief  Function which returns the number of data successfully sent.
//!
//! \param  long c stores the data length.
//- -----------------------------------------------------------------------------------------------
OSEKTL_DataCon (long c)
{
    //TestStep("INFO","Data Transmission done!");
    //write ("Successfully sent data length: %d", c);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function which returns the number of data received.
//!
//! \param  long count stores the data length.
//- -----------------------------------------------------------------------------------------------
OSEKTL_DataInd (long count)
{
    int RIP;
    int i = 0;
    //char tmpString[255];
    RIP = SID + 0x40;
    OSEKTL_GetRxData(RsRxIntData, elcount(RsRxIntData));
	ResponseLength = count;
    if(count <= elcount(RsRxIntData))
    {
        if(0x7F == RsRxIntData[0] && 0x21 == RsRxIntData[2]  )
        {
            OSEKTL_DataReq(RqTxData, ByteSize);
            write("Busy Repeat Request detected -> Repeat last request!");
            write("***********************************************************");
        }
        else
        {
			switch(routineHandle)
			{
				case 10:
					CreateByteString(RsRxIntData, 0, count);
					snprintf(g_TextEvent, elcount(g_TextEvent), "Datablock%d",RsRxIntData[1]);
					TestSupplyTextEvent(g_TextEvent);
                break;
				default:
					CreateByteString(RsRxIntData, 0, count);
					TestSupplyTextEvent("TpMsgReceived");
                break;
			}
        }
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Shows error message from transport layer.
//!
//! \param  long count stores the data length.
//!
//! \note:	Errors:  \n
//!   		• 1: Timeout waiting for CF\n
//!  		• 2: Timeout waiting for FC\n
//!  		• 3: Received Wrong SN\n
//!  		• 4: TxBusy, only one transmission possible at the same time\n
//!   		• 5: Received unexpected PDU\n
//!  		• 6: Timeout while trying to send a CAN message\n
//!  		• 7: Too many FC.WFT sent\n
//!  		• 8: Receiver buffer overflow\n
//!  		• 9: Wrong parameter\n
//!  		• 10: Invalid flow status received\n
//!  		• 11: Transfer has been aborted explicitly\n
//!  		• <0: Unknown Error.
//- -----------------------------------------------------------------------------------------------
OSEKTL_ErrorInd(int error)
{
    write("TP Error %d", error);
}

/// @cond
on sysvar Diag::PlainData
{
    int i = 0;
    int byteLen = 1023;
    char c1;
    char c2;
    int strIndex = 0;
 
    for (i = 0; i < elcount(RqTxStringData); i++)
    {
        RqTxStringData[i] = 0;
    }
    SysGetVariableString(sysvar::Diag::PlainData, RqTxStringData, elcount(RqTxStringData));

    ByteSize = 0;
    for (i = 0; i < byteLen; i++)
    {
        strIndex = i * 2;
        if (RqTxStringData[strIndex] != 0)
        {
            c1 = RqTxStringData[strIndex];
            c2 = RqTxStringData[strIndex + 1];
            RqTxData[i] = char2byte(c1, 16) + char2byte(c2, 1);
            ByteSize++;
        }
    }
    SID = RqTxData[0];
}/// @endcond

/// @cond
on envVar EnvTransmitDataODX
{
    routineHandle = getValue(this);
}/// @endcond

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to convert characters to byte.
//!
//! \param  char c is the character to be converted.
//! \param  int factor identifies the nibble of the byte. For the first nibble, the factor should be 16, for the second it should be 1.
//!
//!
//! \return The characters in byte.
//- -----------------------------------------------------------------------------------------------
byte char2byte (char c, int factor)
{
    switch(c){
		case 'F':
		case 'f': return 15 * factor;
		case 'E':
		case 'e': return 14 * factor;
		case 'D':
		case 'd': return 13 * factor;
		case 'C':
		case 'c': return 12 * factor;
		case 'B':
		case 'b': return 11 * factor;
		case 'A':
		case 'a': return 10 * factor;
		case '9': return 9 * factor;
		case '8': return 8 * factor;
		case '7': return 7 * factor;
		case '6': return 6 * factor;
		case '5': return 5 * factor;
		case '4': return 4 * factor;
		case '3': return 3 * factor;
		case '2': return 2 * factor;
		case '1': return 1 * factor;
    }
    return 0;
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which send diagnostic message and check the response with specified CAN ID.
//!
//! \note	The function can send a string to the ECU from the parameter (Request) and check the received message (Response). \n
//! 		String to byte conversion is needed to send and receive the string parameters, the function also includes this feature. \n
//!			Function set the transmit and receive CAN IDs to send the request message, finally it resets the default CAN IDs.
//! 		
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used to check the response.
//! \param  int rxId is the ID of the transmit messages in CAN.
//! \param  int txId is the ID of the receive messages in CAN.
//!
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponseCanMsgId(char Request[], char Response[], char CompareMode[], int rxId, int txId)
{
	//Check whether is the rxId and the txId is empty (empty = 0)
	if(rxId != 0 && txId !=0)
    {
		setType (rxId, txId);
    }
    else 
    {
		setType (0x73B,0x733);
    }   
    RequestResponseCompareLogic(Request, Response, CompareMode);
    
    //Reset the deafult CAN message IDs
    setType (0x73B,0x733);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which send diagnostic message and check the response
//!
//! \note	The function can send a string to the ECU from the parameter (Request) and check the received message (Response). \n
//! 		String to byte conversion is needed to send and receive the string parameters, the function also includes this feature.
//! 		
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used to check the response.
//!
//! \note	Valid compare modes can be: \n
//!			- Equal: Response has to match with the whole response. \n
//!			- Regexp: Response can be a substring of the response. \n
//!			- None: It is expected that the response does not contain Response as substring. \n
//!			- Suppressed_Equal: Response pending is received and response has to match with the whole response. \n
//!			- Suppressed_Regexp: Response pending is received and response can be a substring of the response. \n
//!			- NotEqual: The received response is not equal with the expected. \n
//!			- RegexpNoFailed: Compare the response with substring without test evaluation.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponse(char Request1[], char Response[], char CompareMode[])
{

	setType(0x73B,0x733);
	RequestResponseCompareLogic(Request1, Response, CompareMode);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to unlock the ECU.
//!
//! \note	It contains the seed and key method and the key calculation with the following process: \n
//! 		1. The tester requests a seed from the system \n
//! 		2. The ECU sends the seed in the positive response \n
//! 		3. The tester sends the key to the ECU \n
//! 		4. The ECU confirms the correct key and unlocks all the services, parameters, \n
//!			   or data in the active diagnostic session that are protected with this key
//!
//! \param  char LoginType is the request should be sent.
//!
//! \note	LoginType should be: \n
//!			- AppRepair: The pin for the repair shop. This pin doesn't unlock the development pin, i.e. has lowest priority. \n
//!			- AppDev: The pin for development. This pin unlocks the repair shop pin, i.e. has highest priority. \n
//!			- FblRep: Unlock the flash bootloader security \n
//!			- RBEOL: Unlock the security key in plant mode
//- -----------------------------------------------------------------------------------------------
testcase Login (char LoginType[])
{
	LoginFunction(LoginType);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to reset the ECU.
//!
//! \note	Reset the ECU and wait after the reset request.
//!
//! \param  dword WaitTime defines the amount of waiting time after the reset (ms).
//- -----------------------------------------------------------------------------------------------
testcase ResetCamera(dword WaitTime)
{
	long result;
  
	RequestResponseCompareLogic("1101", "5101", "Equal");
	result = testWaitForTimeout(WaitTime);
	if (-1 == result)
	{
		TestStepFail("INFO","General error with the testWaitForTimeout function, for example, functionality is not available!");
	}
	else if (-2 == result)
	{
		TestStepFail("INFO","Resume due to constraint violation in the testWaitForTimeout function!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to unlock the ECU.
//!
//! \note	It contains the seed and key method and the key calculation with the following process: \n
//! 		1. The tester requests a seed from the system \n
//! 		2. The ECU sends the seed in the positive response \n
//! 		3. The tester sends the key to the ECU \n
//! 		4. The ECU confirms the correct key and unlocks all the services, parameters, \n
//!			   or data in the active diagnostic session that are protected with this key
//!
//! \param  char LoginType is the request should be sent.
//!
//! \note	LoginType should be: \n
//!			- AppRepair: The pin for the repair shop. This pin doesn't unlock the development pin, i.e. has lowest priority. \n
//!			- AppDev: The pin for development. This pin unlocks the repair shop pin, i.e. has highest priority. \n
//!			- FblRep: Unlock the flash bootloader security \n
//!			- RBEOL: Unlock the security key in plant mode
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void LoginFunction (char LoginType[])
{ 
	dword repairFixValue, devFixValue;
	//init
	repairFixValue = 0x4e87;
	devFixValue = 0x15e57;
  
	if(0 == strncmp("AppRepair", LoginType, strlen(LoginType)))
	{
		TestStep("INFO","The LoginType is: %s", LoginType);
		RequestResponseCompareLogic("2703", "6703.+", "Regexp");
		saveResponse();
		sendKeyAlgo("2704", "6704", repairFixValue, "Equal");
	}
	else if(0 == strncmp("AppDev", LoginType, strlen(LoginType)))
	{
		TestStep("INFO","The LoginType is: %s", LoginType);
		RequestResponseCompareLogic("2703", "6703.+", "Regexp");
		saveResponse();
		sendKeyAlgo("2704", "6704", devFixValue, "Equal");
	}
	else if(0 == strncmp("FblRep", LoginType, strlen(LoginType)))
	{
		TestStep("INFO","The LoginType is: %s", LoginType);
		RequestResponseCompareLogic("2711", "6711.+", "Regexp");
		saveResponse();
		sendKeyAlgoREP("2712", "6712", 0x41916668, 0x12774118, 0x86905668, 0x10371229);
	}
	else if(0 == strncmp("RBEOL", LoginType, strlen(LoginType)))
	{
		TestStep("INFO","The LoginType is: %s", LoginType);
		RequestResponseCompareLogic("2761", "6761.+", "Regexp");
		saveResponse();
		sendKeyAlgoRBEOL("2762", "6762", 0x42444441, 0x80FA1108, "Equal"); 
	}
	else
	{
		TestStepFail("INFO","The LoginType is not valid!");
		TestStepFail("INFO","Please choose from the following Login types: AppDev, AppRepair, FblRep, RBEOL!");
	}  
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to enter into the chosen session.
//!
//! \param  char sessionName is the name of the session we want to enter into.
//!
//! \note	Available sessions are: \n
//!     Default\n
//!     Extended\n
//!     EOL\n
//!     Development\n
//!     Programming
//- -----------------------------------------------------------------------------------------------
testcase DiagSessionCtrl (char sessionName[])
{
	if(0 == strncmp("Default", sessionName, strlen(sessionName)))
	{
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1001", "5001.{8}", "Regexp");  
    }
    else if(0 == strncmp("Extended", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1003", "5003.{8}", "Regexp");   
    }
    else if(0 == strncmp("EOL", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1040", "5040.{8}", "Regexp");
    }
    else if(0 == strncmp("Development", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("104f", "504f.{8}", "Regexp");
    }
    else if(0 == strncmp("Programming", sessionName, strlen(sessionName)))
    {
		TestStep("INFO","The sessionName is: %s", sessionName);
		RequestResponseCompareLogic("1002", "5002.{8}", "Regexp");
    }
    else
    {
		TestStepFail("INFO","The sessionName is not valid!");
		TestStepFail("INFO","Please choose from the following sessionName types: Default, Extended, EOL, Development, Programming!");
    }
    putvalue(EnvTesterPresentOnOff,1);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which stores the value of the given environment variable.
//!
//! \param  char EnvvarName is the name of the environment variable which value should be stored.
//!
//! \note	This test case is mostly used to store signal values by using it's environment variable.
//- -----------------------------------------------------------------------------------------------
testcase SaveSignalValue (char EnvvarName[])
{
    StoredSignalValue = getValue (EnvvarName);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which sets the value of the given environment variable to a previously stored value.
//!
//! \param  char EnvvarName is the name of the environment variable which value should be set.
//! 
//!\note	This test case is mostly used after the SaveSignalValue test case to restore the value
//!			of a specific signal by it's environment variable.
//- -----------------------------------------------------------------------------------------------
testcase RestoreSignalValue (char EnvvarName[])
{
    putValue (EnvvarName, StoredSignalValue);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to wait for the occurrence of the next specific message.
//!
//! \param  char MessageName is the name of the message that should be awaited.
//! \param  long Timeout is the maximum time that should be waited [ms].
//- -----------------------------------------------------------------------------------------------
testcase WaitForMessage (char MessageName[], long Timeout)
{
    dword MessageID;
    MessageID = GetMessageID(MessageName);

	write("ID= %x", MessageID);
    
    WaitForMessageFunction(MessageID, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase which checks the given value against the value of the signal and waits for the given value.
//!
//! \note If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//!
//! \param  signal signalName is the name of the signal which is tested.
//! \param  int signalValue is the value of the tested signal what we wait for.
//! \param  long Timeout is the timeout for the test.
//- -----------------------------------------------------------------------------------------------
testcase WaitForSignalValue (signal * signalName,  int signalValue, long Timeout)
{
  WaitForSignalValueFunction(signalName, signalValue, Timeout);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to enter specific session.
//!
//! \param  int session_nr is the identifier of session which should be entered.
//! 
//! \note	Available session identifiers:\n
//!			0: Default session\n
//!			1: Extended session\n
//!			2: EOL\n
//!			3: Development session\n
//!			4: Programming session\n
//!	\n
//!			This function makes the session changing dynamic inside loops.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void iterateSession(int session_nr)
{
	if(session_nr == 0)
    {
        RequestResponseCompareLogic("1001", "5001.+", "Regexp");
    }
    else if(session_nr == 1)
    {
        RequestResponseCompareLogic("1003", "5003.+", "Regexp");
    }
    else if(session_nr == 2)
    {
        RequestResponseCompareLogic("1040", "5040.+", "Regexp");
    }
    else if(session_nr == 3)
    {
        RequestResponseCompareLogic("104f", "504f.+", "Regexp");
    }
    else if(session_nr == 4)
    {
        RequestResponseCompareLogic("1002", "5002.+", "Regexp");
    }
    else
    {
        TestStepFail("INFO","The session number is not valid!");
        TestStepFail("INFO","Please choose from the following session numbers: 0, 1, 2, 3, 4!");
    }  
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that performs specific login.
//!
//! \param  int login_nr is the identifier of login which should be performed.
//! 
//! \note	Available login identifiers:\n
//!			0: No login\n
//!			1: Garage login\n
//!			2: Development login\n
//!\n
//!			This function makes the login dynamic inside loops.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
/*void iterateLogin(int login_nr)
{
	if(login_nr == 0)
    {
        //login level 0 -> no login
    }
    else if(login_nr == 1)
    {
        LoginFunction(AppRepair);
    }
    else if(login_nr == 2)
    {
        LoginFunction(AppDev);
    }
    else
    {
        TestStepFail("INFO","The login number is not valid!");
        TestStepFail("INFO","Please choose from the following login numbers: 0, 1, 2!");
    }  
}*/
/// @cond
on timer t10ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms   
}/// @endcond

/// @cond
on timer t20ms
{
    TestSupplyTextEvent("Minimum time delay is reached!");
    //setTimer(t10ms,10); //set timer (t20ms) to 20ms    
}/// @endcond

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that measures the time interval between a sent request and an expected response.
//!
//! \note	This testcase sends a diagnostic request and waits for a specific response. \n
//! 		Measures the time interval between a sent request and the awaited response. \n
//! 		This time interval is compared to an expected time interval.
//!
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used.
//! \param  char aTime1 is the low threshold of the expected time interval in ms.
//! \param  char aTime2 is the high threshold of the expected time interval in ms.
//- -----------------------------------------------------------------------------------------------
testcase RequestResponseTimeElapsed(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
	RequestResponseTimeElapsedFn(Request, Response, CompareMode, aTime1, aTime2);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that measures the time interval between a sent request and an expected response.
//!
//! \note	This function sends a diagnostic request and waits for a specific response. \n
//! 		Measures the time interval between the first sent request and the awaited response. \n
//! 		This time interval is compared to an expected time interval.
//!
//! \param  char Request is the request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used.
//! \param  char aTime1 is the low threshold of the expected time interval in ms.
//! \param  char aTime2 is the high threshold of the expected time interval in ms.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void RequestResponseTimeElapsedFn(char Request[], char Response[], char CompareMode[], char aTime1[], char aTime2[])
{
	byte responsePending;
	long result;
	long timeOutValue;
	int numberRPs;
	float startTime1;
	float startTime2;
	float endTime;
	int respOk;
	int i;
	float time1;
	float time2;
 
	//Init
	respOk = 0;
	endTime = 0;
	i = 0;
	time1 = 0;
	time2 = 0;
  
	time1 = atodbl(aTime1);
	time2 = atodbl(aTime2);
    
	responsePending = 0;
	numberRPs = 0;
	timeOutValue = 5000;
  
	//Check the validity of the compare mode
	if( ! (0 == strncmp("Equal", CompareMode,strlen(CompareMode)) || 0 == strncmp("Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("None", CompareMode,strlen(CompareMode)) || 0 == strncmp("Suppressed_Equal", CompareMode,strlen(CompareMode)) 
		|| 0 == strncmp("Suppressed_Regexp", CompareMode,strlen(CompareMode)) || 0 == strncmp("NotEqual", CompareMode,strlen(CompareMode))|| 0 == strncmp("RegexpNoFailed", CompareMode,strlen(CompareMode))))
	{
		TestStepFail("INFO","The CompareMode '%s' is not valid!", CompareMode);
		TestStepFail("INFO","Please choose from the following CompareMode types: Equal, Regexp, None, NotEqual, Suppressed_Equal, Suppressed_Regexp or RegexpNoFailed!");
	}
	else
	{
		//The compare mode is valid
		    
		//Set timer (t20ms) to 20ms
		setTimer(t20ms, 20);
		//Store start time
		startTime1 = timeNow()/100.0;
  
		//START check the response from the camera: 
		do
		{ 
			if( (endTime - startTime2)/100.0 < 20.0 && (i != 0)) //
		{
			TestWaitForTextEvent("Minimum time delay is reached!", 100);
		}
		else if(  timeToElapse(t10ms) > 0 )
		{
			//long timeToElapse(mstimer t) (Form 2)			
			TestWaitForTextEvent("Maximum time delay is reached!", 100);
		}
      
  		CharArray2Byte(Request);              // It is necessary to convert the char array to byte array before sending it out with the inside Vector function
  		TestStep("INFO","REQUEST: %s (The compare mode is: %s)", Request, CompareMode);
      
                //OSEKTL_ActivateAck(1);
  		OSEKTL_DataReq(RqTxData, ByteSize);   //Sending out Request in a RxTxData global byte array
  		setType (0x73B,0x733);

		setTimer(t20ms, 20);
		startTime2 = timeNow()/100.0;
      
		//Wait for the message from the camera
		responsePending = 0;
		result = TestWaitForTextEvent("TpMsgReceived", timeOutValue);
                endTime = timeNow()/100.0;
      
		// if elapsed time more than 20ms, start 10ms counter
		if( (endTime - startTime2)/100.0 >= 20.0 )
	    {
		    setTimer(t10ms,10); // set timer (t10ms) to 10ms
	    }
      
		if(result == 0)
		{  
			//If no response is received
			responseMatching(CompareMode, Response, numberRPs, "Noresponse", result);
		}
		else if(result == 1)
		{    
			//If response is received
			//Negative branch starts
			if( RsRxIntData[0] == 0x7f && RsRxIntData[1] == SID ) 
			{ 
				respOk = 0;
				if( RsRxIntData[2] == 0x78 )
				{
					TestStep("INFO","Response Pending received from ECU");
					responsePending = 1;
					numberRPs++;
					timeOutValue = 10000;
				}
				else
				{
					//TestStep("INFO","Negative Response from ECU!");
					responseMatching(CompareMode, Response, numberRPs, "NRC", result);
				}
			}
			//Positive branch starts
			if( RsRxIntData[0] == (SID + 0x40) )  
			{
				//TestStep("INFO","Positive Response from ECU!");
				respOk = responseMatching(CompareMode, Response, numberRPs, "response", result);
			}	
		}
		i++;
	        }while( ((responsePending == 1) && (numberRPs < 24)) || ((respOk != 1) && ((endTime - startTime1) < 35000.0)) );  //Handling of pending response  and maximum testcase duration
	        }
		if( responsePending == 1 )
		{
			TestStepFail("INFO","Timeout while waiting for diag response!");
		}

  //Evaluation of test result
	TestStep("INFO","Start Time [ms]: %f", startTime1);
	TestStep("INFO","End Time [ms]: %f", endTime);
	TestStep("INFO","Elapsed Time [ms]: %.0f", (endTime - startTime1));
  
	if((endTime - startTime1) >= 35000.0)
	{
		testStepFail("INFO", "TestStep timeout!");
	}
	else if( (endTime - startTime1) >= time1 && (endTime - startTime1) <= time2)
	{
		testStepPass("INFO", "Elapsed time is in the expected range!");
	}
	else
	{
		testStepFail("INFO", "Elapsed time is out of the expected range!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that saves timestamp for start time.
//- -----------------------------------------------------------------------------------------------
testcase TimeNowStart()
{    
    tMesStart = timeNow();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that saves timestamp for end time, calculates the time elapsed from the start time saved 
//! 		with testcase TimeNowStart and compares it to an expected time interval.
//!
//! \param  char aTime1 is the low threshold of the expected time interval.
//! \param  char aTime2 is the high threshold of the expected time interval.
//- -----------------------------------------------------------------------------------------------
testcase TimeNowEnd(char aTime1[], char aTime2[])
{    
	float time1;
	float time2;
	float tMesEnd;
  
	time1 = 0;
	time2 = 0;
	
	time1 = atodbl(aTime1);
	time2 = atodbl(aTime2);
	
	tMesEnd = timeNow();
	
	TestStep("INFO","Start Time [ms]: %f", tMesStart);
	TestStep("INFO","End Time [ms]: %f", tMesEnd);
	TestStep("INFO","Elapsed Time [ms]: %.0f", (tMesEnd - tMesStart));
	
	if( (tMesEnd - tMesStart) >= time1 && (tMesEnd - tMesStart) <= time2)
	{
		testStepPass("INFO", "Elapsed time is in the expected range!");
	}
	else
	{
		testStepFail("INFO", "Elapsed time is out of the expected range!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that stores the arrived response in the byteString variable.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void CreateByteString (byte response[], long offset,long responseLength)
{
    char intString[1023];
    char catString[10];
    int i=0;
    long dataLength;

    snprintf(byteString, elcount(byteString), "");
    dataLength = responseLength;

    for(i=offset; i < dataLength;i++)
    {
        ltoa(response[i], intString, 16);

        if( 1==strlen(intString) )
        {
            snprintf(catString, elcount(catString), "0");
            strncat(catString, intString, elcount(catString));
            strncpy(intString, catString, elcount(intString));
        }
       
        strncat(byteString, intString, elcount(byteString));
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to wait for the occurrence of the next specific message.
//!
//! \param  dword MessageID is the numeric ID of the message that should be awaited.
//! \param  long Timeout is the maximum time that should be waited [ms].
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void WaitForMessageFunction(dword MessageID, long Timeout)
{
	long result;
  
	result = 0;
  
	if(MessageID == 0x250)
	{
		//result = TestWaitForMessage(RDR1_Header, Timeout);   
	}
	else if(MessageID == 0x251)
	{
		//result = TestWaitForMessage(RDR1_Obj_01, Timeout);;   
	}
	else if(MessageID == 0x252)
	{
		//result = TestWaitForMessage(RDR1_Obj_02, Timeout);;   
	}
	else if(MessageID == 0x253)
	{
		//result = TestWaitForMessage(RDR1_Obj_03, Timeout);;   
	}
	else if (MessageID == 0x254)
	{
		//result = TestWaitForMessage(RDR1_Obj_04, Timeout);;   
	}
	else
	{
		result = TestWaitForMessage(MessageID, Timeout);      
	}
  
	if (result == 1)
	{
		//Signal with expected value arrived!      
		TestStepPass("INFO","The message arrived");
	}
	else if (result == 0)
	{ 
		//Timeout occured!       
		TestStepFail("INFO","The message has not arrived within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Constraint violation!");
	}
	else
	{
		TestStepFail("INFO","General error!");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function that checks the given value against the value of the signal and waits for the given value.
//!  
//! \note If this condition is already met when this function is called, it returns immediately 
//!   without waiting. The test step is evaluated as either passed or failed depending on the results.
//!
//! \param  signal signalName is the name of the signal which is tested.
//! \param  int signalValue is the value of the tested signal what we wait for.
//! \param  long Timeout is the timeout for the test.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void WaitForSignalValueFunction (signal * signalName,  int signalValue, long Timeout)
{
	long result;
	float signalActualValue;

	result = 0;
	signalActualValue = 0;
  
	result = TestWaitForSignalMatch (signalName, signalValue, Timeout);
  
	if (result == 1)
	{
		//Signal with expected value arrived!      
		TestStepPass("INFO","The signal arrived with the expected value: %.d", signalValue);
	}
	else if (result == 0)
	{ 
		//Timeout occured! 
		signalActualValue = getSignal(signalName);
		TestStep("INFO","The signal has the following value: %d,", signalActualValue);        
		TestStepFail("INFO","The signal has not arrived with the expected value within timeout!");  
	}
	else if(result == -2)
	{
		TestStepFail("INFO","Signal is not valid");
	}
	else
	{
		TestStepFail("INFO","General error");
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to turn on the Response On Event for the current and the next ignition cycle.
//!
//! \return No return value.
//- -----------------------------------------------------------------------------------------------
void ResponseOnEvent()
{
	putvalue(EnvTesterPresentOnOff,1);
	RequestResponseCompareLogic("1003", "5003.+", "Regexp");
	RequestResponseCompareLogic("86010408190e", "c601ff04", "Regexp");
	RequestResponseCompareLogic("1040", "5040.+", "Regexp");
	RequestResponseCompareLogic("86050408190e", "c605ff04", "Regexp");
	RequestResponseCompareLogic("1001", "5001.+", "Regexp");
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to wait till a specific DTC has been qualified.
//!
//! \param  char Request is the diagnostic request should be sent.
//! \param  char Response is the expected response should be awaited.
//! \param  char CompareMode is the compare mode should be used.
//- -----------------------------------------------------------------------------------------------
testcase WaitForDTC(char Request[], char Response[], char CompareMode[])
{
	int result;
	int i;
	
	result = 0;
	i =0;
		
	while(result ==0 && i<120)
	{
		//Wait 2 s
		testWaitForTimeout(2000);
		//Read the Error memory whether the DTC of the failure is stored in or not
		result = RequestResponseCompareLogic(Request, Response, CompareMode);
    
		//Increment i variable by 1
		i++;
	}
	//Verification of test result
	if (i!=120)
	{
		//The testcase is passed, the expected response has received
		testStepPass("INFO", "The DTC is activated!");
	}	
    else
    {
	  //4 mins elapsed and qualification did not occure
	  testStepFail("INFO", "TestStep timeout!");
    }
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to write default coding parameters into ECU.
//!  
//! \param  char Project is the project variant which default coding has to be written into ECU.
//!
//! \note 	Available parameters: \n
//!			- MQBB \n
//!			- PQ
//- -----------------------------------------------------------------------------------------------
testcase CodingDefault(char Project[])
{
	if(0 == strncmp("MQBB", Project,strlen(Project)))
	{
		RequestResponseCompareLogic("1003", "5003.+", "Regexp");
		RequestResponseCompareLogic("2ef198010203040506", "6ef198", "Equal");
		RequestResponseCompareLogic("2ef199020202", "6ef199", "Equal");
		RequestResponseCompareLogic("2e060000000000000004020120235fc050a100900084100040", "6e0600", "Equal");
		strncpy(codeString, "2e060000000000000004020120235fc050a100900084100040", elcount(codeString));
	}
	else if(0 == strncmp("PQ", Project,strlen(Project)))
	{
		RequestResponseCompareLogic("1003", "5003.+", "Regexp");
		RequestResponseCompareLogic("2ef198010203040506", "6ef198", "Equal");
		RequestResponseCompareLogic("2ef199020202", "6ef199", "Equal");
		RequestResponseCompareLogic("2e0600000000000000040201202357c088a10090000e100040", "6e0600", "Equal");
		strncpy(codeString, "2e0600000000000000040201202357c088a10090000e100040", elcount(codeString));
	}
	else
	{
		TestStepFail("INFO","The project: '%s' is not valid!", Project);
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to modify the coding parameters which is read out from the ECU.
//!  
//! \param  char Project is the project variant which default coding has to be written into ECU.
//!
//! \note 	ReadCoding() must be used before this to create the basic codeString.
//!			The modified parameters can be written into ECU with WriteCoding().
//- -----------------------------------------------------------------------------------------------
testcase CodingModify(char CodeByte[], char CodeByteValue[])
{
	if(0 == strncmp("Brand", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("VW", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '0';
		}
		else if(0 == strncmp("VW_N", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '1';
		}
		else if(0 == strncmp("Skoda", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '2';
		}
		else if(0 == strncmp("Seat", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '3';
		}
		else if(0 == strncmp("Audi", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '4';
		}
		else if(0 == strncmp("Bentley", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '5';
		}
		else if(0 == strncmp("Lamborghini", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '6';
		}
		else if(0 == strncmp("Bugatti", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '7';
		}
		else if(0 == strncmp("Porsche", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '8';
		}
		else if(0 == strncmp("quattro_GmbH", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = '0';
			codeString[7] = '9';
		}
		else if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[6] = 'f';
			codeString[7] = 'f';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Class", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("A000", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '0';
		}
		else if(0 == strncmp("A00", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '1';
		}
		else if(0 == strncmp("A0", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '2';
		}
		else if(0 == strncmp("A", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '3';
		}
		else if(0 == strncmp("B", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '4';
		}
		else if(0 == strncmp("C", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '5';
		}
		else if(0 == strncmp("D", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '6';
		}
		else if(0 == strncmp("E", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '7';
		}
		else if(0 == strncmp("E+", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '8';
		}
		else if(0 == strncmp("other", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = '0';
			codeString[9] = '9';
		}
		else if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[8] = 'f';
			codeString[9] = 'f';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Generation", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '0';
		}
		else if(0 == strncmp("Generation_1", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '1';
		}
		else if(0 == strncmp("Generation_2", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '2';
		}
		else if(0 == strncmp("Generation_3", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '3';
		}
		else if(0 == strncmp("Generation_4", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '4';
		}
		else if(0 == strncmp("Generation_5", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '5';
		}
		else if(0 == strncmp("Generation_6", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '6';
		}
		else if(0 == strncmp("Generation_7", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '7';
		}
		else if(0 == strncmp("Generation_8", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '8';
		}
		else if(0 == strncmp("Generation_9", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[10] = '0';
			codeString[11] = '9';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Bodystyle", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Limousine_shortback", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '0';
		}
		else if(0 == strncmp("Limousine_notchback", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '1';
		}
		else if(0 == strncmp("Estate", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '2';
		}
		else if(0 == strncmp("Limousine_hatchback", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '3';
		}
		else if(0 == strncmp("Coupe", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '4';
		}
		else if(0 == strncmp("Cabriolet", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '5';
		}
		else if(0 == strncmp("Suv", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '6';
		}
		else if(0 == strncmp("Pickup_SLW", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '7';
		}
		else if(0 == strncmp("MPV", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '8';
		}
		else if(0 == strncmp("other", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = '0';
			codeString[13] = '9';
		}
		else if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[12] = 'f';
			codeString[13] = 'f';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Enhancements", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '0';
		}
		else if(0 == strncmp("Specifically_wheelbases", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '1';
		}
		else if(0 == strncmp("Different_front_rear", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '2';
		}
		else if(0 == strncmp("Roof_variant", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '3';
		}
		else if(0 == strncmp("Cross_allroad", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '4';
		}
		else if(0 == strncmp("performance_variants_1", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '5';
		}
		else if(0 == strncmp("performance_variants_2", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '6';
		}
		else if(0 == strncmp("Alternative_drive", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '7';
		}
		else if(0 == strncmp("other", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[14] = '0';
			codeString[15] = '8';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Region", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("EU", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '0';
		}
		else if(0 == strncmp("NA", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '1';
		}
		else if(0 == strncmp("ME", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '2';
		}
		else if(0 == strncmp("CN", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '3';
		}
		else if(0 == strncmp("CS", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '4';
		}
		else if(0 == strncmp("LA", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '5';
		}
		else if(0 == strncmp("SA", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '6';
		}
		else if(0 == strncmp("RU", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '7';
		}
		else if(0 == strncmp("IN", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '8';
		}
		else if(0 == strncmp("UA", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = '9';
		}
		else if(0 == strncmp("AS", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = '0';
			codeString[17] = 'a';
		}
		else if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[16] = 'f';
			codeString[17] = 'f';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Country", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '0';
		}
		else if(0 == strncmp("RDW", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '1';
		}
		else if(0 == strncmp("NAR", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '2';
		}
		else if(0 == strncmp("Hot_country", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '3';
		}
		else if(0 == strncmp("Europe", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '4';
		}
		else if(0 == strncmp("Japan", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '5';
		}
		else if(0 == strncmp("china", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[18] = '0';
			codeString[19] = '6';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Chassis", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[20] = '0';
			codeString[21] = '0';
		}
		else if(0 == strncmp("Steel_springs", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[20] = '0';
			codeString[21] = '1';
		}
		else if(0 == strncmp("Air_chassis", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[20] = '0';
			codeString[21] = '2';
		}
		else if(0 == strncmp("Magnetic_ride", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[20] = '0';
			codeString[21] = '5';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Steering", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[22] = '0';
			codeString[23] = '0';
		}
		else if(0 == strncmp("Dynamic_steering_bar", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[22] = '0';
			codeString[23] = '1';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Traffic", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Left_traffic", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[24] = '0';
		}
		else if(0 == strncmp("Right_traffic", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[24] = '2';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("WindShieldType", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[25] = '0';
		}
		else if(0 == strncmp("Heat_protecting_glass", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[25] = '2';
		}
		else if(0 == strncmp("Clear_glass", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[25] = '4';
		}
		else if(0 == strncmp("climate_glass", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[25] = '6';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Navigation", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[26] = '0';
		}
		else if(0 == strncmp("MIB_Standard", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[26] = '1';
		}
		else if(0 == strncmp("MIB_High", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[26] = '2';
		}
		else if(0 == strncmp("MMI3G", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[26] = '3';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("PSD", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[27] = '0';
		}
		else if(0 == strncmp("PSD_12", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[27] = '1';
		}
		else if(0 == strncmp("PSD_14", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[27] = '2';
		}
		else if(0 == strncmp("PSD_15", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[27] = '3';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Rainsensor", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[28] == '5')
			{
				codeString[28] = '1';
			}
			else if(codeString[28] == '4')
			{
				codeString[28] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[28] == '1')
			{
				codeString[28] = '5';
			}
			else if(codeString[28] == '0')
			{
				codeString[28] = '4';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("BlindSpotDetection", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[28] == '5')
			{
				codeString[28] = '4';
			}
			else if(codeString[28] == '1')
			{
				codeString[28] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[28] == '4')
			{
				codeString[28] = '5';
			}
			else if(codeString[28] == '0')
			{
				codeString[28] = '1';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("PedAlarmRadar", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == 'f')
			{
				codeString[29] = '7';
			}
			else if(codeString[29] == 'e')
			{
				codeString[29] = '6';
			}
			else if(codeString[29] == 'd')
			{
				codeString[29] = '5';
			}
			else if(codeString[29] == 'c')
			{
				codeString[29] = '4';
			}
			else if(codeString[29] == 'b')
			{
				codeString[29] = '3';
			}
			else if(codeString[29] == 'a')
			{
				codeString[29] = '2';
			}
			else if(codeString[29] == '9')
			{
				codeString[29] = '1';
			}
			else if(codeString[29] == '8')
			{
				codeString[29] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{	
			if(codeString[29] == '0')
			{
				codeString[29] = '8';
			}
			else if(codeString[29] == '1')
			{
				codeString[29] = '9';
			}
			else if(codeString[29] == '2')
			{
				codeString[29] = 'a';
			}
			else if(codeString[29] == '3')
			{
				codeString[29] = 'b';
			}
			else if(codeString[29] == '4')
			{
				codeString[29] = 'c';
			}
			else if(codeString[29] == '5')
			{
				codeString[29] = 'd';
			}
			else if(codeString[29] == '6')
			{
				codeString[29] = 'e';
			}
			else if(codeString[29] == '7')
			{
				codeString[29] = 'f';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("ACC", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == 'f')
			{
				codeString[29] = 'b';
			}
			else if(codeString[29] == 'e')
			{
				codeString[29] = 'a';
			}
			else if(codeString[29] == 'd')
			{
				codeString[29] = '9';
			}
			else if(codeString[29] == 'c')
			{
				codeString[29] = '8';
			}
			else if(codeString[29] == '7')
			{
				codeString[29] = '3';
			}
			else if(codeString[29] == '6')
			{
				codeString[29] = '2';
			}
			else if(codeString[29] == '5')
			{
				codeString[29] = '1';
			}
			else if(codeString[29] == '4')
			{
				codeString[29] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == '0')
			{
				codeString[29] = '4';
			}
			else if(codeString[29] == '1')
			{
				codeString[29] = '5';
			}
			else if(codeString[29] == '2')
			{
				codeString[29] = '6';
			}
			else if(codeString[29] == '3')
			{
				codeString[29] = '7';
			}
			else if(codeString[29] == '8')
			{
				codeString[29] = 'c';
			}
			else if(codeString[29] == '9')
			{
				codeString[29] = 'd';
			}
			else if(codeString[29] == 'a')
			{
				codeString[29] = 'e';
			}
			else if(codeString[29] == 'b')
			{
				codeString[29] = 'f';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("SWA", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == 'f')
			{
				codeString[29] = 'd';
			}
			else if(codeString[29] == 'e')
			{
				codeString[29] = 'c';
			}
			else if(codeString[29] == 'b')
			{
				codeString[29] = '9';
			}
			else if(codeString[29] == 'a')
			{
				codeString[29] = '8';
			}
			else if(codeString[29] == '7')
			{
				codeString[29] = '5';
			}
			else if(codeString[29] == '6')
			{
				codeString[29] = '4';
			}
			else if(codeString[29] == '3')
			{
				codeString[29] = '1';
			}
			else if(codeString[29] == '2')
			{
				codeString[29] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == '0')
			{
				codeString[29] = '2';
			}
			else if(codeString[29] == '1')
			{
				codeString[29] = '3';
			}
			else if(codeString[29] == '4')
			{
				codeString[29] = '6';
			}
			else if(codeString[29] == '5')
			{
				codeString[29] = '7';
			}
			else if(codeString[29] == '8')
			{
				codeString[29] = 'a';
			}
			else if(codeString[29] == '9')
			{
				codeString[29] = 'b';
			}
			else if(codeString[29] == 'c')
			{
				codeString[29] = 'e';
			}
			else if(codeString[29] == 'd')
			{
				codeString[29] = 'f';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("AAG", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == 'f')
			{
				codeString[29] = 'e';
			}
			else if(codeString[29] == 'd')
			{
				codeString[29] = 'c';
			}
			else if(codeString[29] == 'b')
			{
				codeString[29] = 'a';
			}
			else if(codeString[29] == '9')
			{
				codeString[29] = '8';
			}
			else if(codeString[29] == '7')
			{
				codeString[29] = '6';
			}
			else if(codeString[29] == '5')
			{
				codeString[29] = '4';
			}
			else if(codeString[29] == '3')
			{
				codeString[29] = '2';
			}
			else if(codeString[29] == '1')
			{
				codeString[29] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[29] == '0')
			{
				codeString[29] = '1';
			}
			else if(codeString[29] == '2')
			{
				codeString[29] = '3';
			}
			else if(codeString[29] == '4')
			{
				codeString[29] = '5';
			}
			else if(codeString[29] == '6')
			{
				codeString[29] = '7';
			}
			else if(codeString[29] == '8')
			{
				codeString[29] = '9';
			}
			else if(codeString[29] == 'a')
			{
				codeString[29] = 'b';
			}
			else if(codeString[29] == 'c')
			{
				codeString[29] = 'd';
			}
			else if(codeString[29] == 'e')
			{
				codeString[29] = 'f';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("ESP", CodeByte,strlen(CodeByte)))
	{
		codeString[31] = '0';
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[30] == 'c')
			{
				codeString[30] = '4';
			}
			if(codeString[30] == '8')
			{
				codeString[30] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[30] == '4')
			{
				codeString[30] = 'c';
			}
			if(codeString[30] == '0')
			{
				codeString[30] = '8';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("PLA", CodeByte,strlen(CodeByte)))
	{
		codeString[31] = '0';
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[30] == 'c')
			{
				codeString[30] = '8';
			}
			if(codeString[30] == '4')
			{
				codeString[30] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[30] == '8')
			{
				codeString[30] = 'c';
			}
			if(codeString[30] == '0')
			{
				codeString[30] = '4';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Variant", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == 'a' || codeString[32] == '6')
			{
				codeString[32] = '2';
			}
			else if(codeString[32] == '9' || codeString[32] == '5')
			{
				codeString[32] = '1';
			}
			else
			{ //8, 0, 4
				codeString[32] = '0';
			}
		}
		else if(0 == strncmp("MQB", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '9')
			{
				codeString[32] = '5';
			}
			else if(codeString[32] == 'a')
			{
				codeString[32] = '6';
			}
			else
			{ //8, 0
				codeString[32] = '4';
			}
		}
		else if(0 == strncmp("PQ", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '5')
			{
				codeString[32] = '9';
			}
			else if(codeString[32] == '6')
			{
				codeString[32] = 'a';
			}
			else
			{ //0, 4
				codeString[32] = '8';
			}	
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Personalization", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '4' || codeString[32] == '5' || codeString[32] == '6')
			{
				codeString[32] = '4';
				codeString[33] = '0';
			}
			else if(codeString[32] == '0' || codeString[32] == '1' || codeString[32] == '2')
			{
				codeString[32] = '0';
				codeString[33] = '0';
			}
			else if(codeString[32] == '8' || codeString[32] == '9' || codeString[32] == 'a')
			{
				codeString[32] = '8';
				codeString[33] = '0';
			}		
		}
		else if(0 == strncmp("Version_0.1", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '4' || codeString[32] == '5' || codeString[32] == '6')
			{
				codeString[32] = '4';
				codeString[33] = '8';
			}
			else if(codeString[32] == '0' || codeString[32] == '1' || codeString[32] == '2')
			{
				codeString[32] = '0';
				codeString[33] = '8';
			}
			else if(codeString[32] == '8' || codeString[32] == '9' || codeString[32] == 'a')
			{
				codeString[32] = '8';
				codeString[33] = '8';
			}	
		}
		else if(0 == strncmp("Version_1.x", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '4' || codeString[32] == '5' || codeString[32] == '6')
			{
				codeString[32] = '5';
				codeString[33] = '0';
			}
			else if(codeString[32] == '0' || codeString[32] == '1' || codeString[32] == '2')
			{
				codeString[32] = '1';
				codeString[33] = '0';
			}
			else if(codeString[32] == '8' || codeString[32] == '9' || codeString[32] == 'a')
			{
				codeString[32] = '9';
				codeString[33] = '0';
			}
		}
		else if(0 == strncmp("Reserve_1", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '4' || codeString[32] == '5' || codeString[32] == '6')
			{
				codeString[32] = '5';
				codeString[33] = '8';
			}
			else if(codeString[32] == '0' || codeString[32] == '1' || codeString[32] == '2')
			{
				codeString[32] = '1';
				codeString[33] = '8';
			}
			else if(codeString[32] == '8' || codeString[32] == '9' || codeString[32] == 'a')
			{
				codeString[32] = '9';
				codeString[33] = '8';
			}
		}
		else if(0 == strncmp("Reserve_2", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[32] == '4' || codeString[32] == '5' || codeString[32] == '6')
			{
				codeString[32] = '6';
				codeString[33] = '0';
			}
			else if(codeString[32] == '0' || codeString[32] == '1' || codeString[32] == '2')
			{
				codeString[32] = '2';
				codeString[33] = '0';
			}
			else if(codeString[32] == '8' || codeString[32] == '9' || codeString[32] == 'a')
			{
				codeString[32] = 'a';
				codeString[33] = '0';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Intervention", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("early", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[34] = '0';
		}
		else if(0 == strncmp("late", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[34] = '4';
		}
		else if(0 == strncmp("early_setting_over_menu", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[34] = '8';
		}
		else if(0 == strncmp("late_setting_over_menu", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[34] = 'a';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("RadarInterface", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{		
			if(codeString[35] == '9')
			{
				codeString[35] = '8';
			}
			else if(codeString[35] == '5')
			{
				codeString[35] = '4';
			}
			else if(codeString[35] == '1')
			{
				codeString[35] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[35] == '0')
			{
				codeString[35] = '1';
			}
			else if(codeString[35] == '4')
			{
				codeString[35] = '5';
			}
			else if(codeString[35] == '8')
			{
				codeString[35] = '9';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Perso_HC", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[35] == '4' || codeString[35] == '8')
			{
				codeString[35] = '0';
			}
			else if (codeString[35] == '5' || codeString[35] == '9')
			{
				codeString[35] = '1';
			}
		}
		else if(0 == strncmp("Active", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[35] == '0' || codeString[35] == '8')
			{
				codeString[35] = '4';
			}
			else if (codeString[35] == '1' || codeString[35] == '9')
			{
				codeString[35] = '5';
			}
		}
		else if(0 == strncmp("Last_settings", CodeByteValue,strlen(CodeByteValue)))

		{
			if(codeString[35] == '0' || codeString[35] == '4')
			{
				codeString[35] = '8';
			}
			else if (codeString[35] == '1' || codeString[35] == '5')
			{
				codeString[35] = '9';
			}

		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("HC", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == 'd')
			{
				codeString[38] = '5';
			}
			else if(codeString[38] == 'c')
			{
				codeString[38] = '4';
			}
			else if(codeString[38] == '9')
			{
				codeString[38] = '1';
			}
			else if(codeString[38] == '8')
			{
				codeString[38] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == '0')
			{
				codeString[38] = '8';
			}
			else if(codeString[38] == '1')
			{
				codeString[38] = '9';
			}
			else if(codeString[38] == '4')
			{
				codeString[38] = 'c';
			}
			else if(codeString[38] == '5')
			{
				codeString[38] = 'd';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("HcCharacteristic", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == 'd')
			{
				codeString[38] = '9';
			}
			else if(codeString[38] == 'c')
			{
				codeString[38] = '8';
			}
			else if(codeString[38] == '5')
			{
				codeString[38] = '1';
			}
			else if(codeString[38] == '4')
			{
				codeString[38] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == '0')
			{
				codeString[38] = '4';
			}
			else if(codeString[38] == '1')
			{
				codeString[38] = '5';
			}
			else if(codeString[38] == '8')
			{
				codeString[38] = 'c';
			}
			else if(codeString[38] == '9')
			{
				codeString[38] = 'd';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("VZE", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == 'd')
			{
				codeString[38] = 'c';
			}
			else if(codeString[38] == '9')
			{
				codeString[38] = '8';
			}
			else if(codeString[38] == '5')
			{
				codeString[38] = '4';
			}
			else if(codeString[38] == '1')
			{
				codeString[38] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[38] == '0')
			{
				codeString[38] = '1';
			}
			else if(codeString[38] == '4')
			{
				codeString[38] = '5';
			}
			else if(codeString[38] == '8')
			{
				codeString[38] = '9';
			}
			else if(codeString[38] == 'c')
			{
				codeString[38] = 'd';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("EmergencyAssist", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '4' || codeString[39] == '8')
			{
				codeString[39] = '0';
			}
			else if(codeString[39] == '5' || codeString[39] == '9')
			{
				codeString[39] = '1';
			}
			else if(codeString[39] == '6' || codeString[39] == 'a')
			{
				codeString[39] = '2';
			}
			else if(codeString[39] == '7' || codeString[39] == 'b')
			{
				codeString[39] = '3';
			}
		}
		else if(0 == strncmp("EA_Variant_1", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '0' || codeString[39] == '8')
			{
				codeString[39] = '4';
			}
			else if(codeString[39] == '1' || codeString[39] == '9')
			{
				codeString[39] = '5';
			}
			else if(codeString[39] == '2' || codeString[39] == 'a')
			{
				codeString[39] = '6';
			}
			else if(codeString[39] == '3' || codeString[39] == 'b')
			{
				codeString[39] = '7';
			}
		}
		else if(0 == strncmp("EA_Variant_2", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '0' || codeString[39] == '4')
			{
				codeString[39] = '8';
			}
			else if(codeString[39] == '1' || codeString[39] == '5')
			{
				codeString[39] = '9';
			}
			else if(codeString[39] == '2' || codeString[39] == '6')
			{
				codeString[39] = 'a';
			}
			else if(codeString[39] == '3' || codeString[39] == '7')
			{
				codeString[39] = 'b';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("LaneAssistOffText", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("disabled", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == 'a')
			{
				codeString[39] = '8';
			}
			else if(codeString[39] == 'b')
			{
				codeString[39] = '9';
			}
			else if(codeString[39] == '6')
			{
				codeString[39] = '4';
			}
			else if(codeString[39] == '2')
			{
				codeString[39] = '0';
			}
			else if(codeString[39] == '3')
			{
				codeString[39] = '1';
			}
			else if(codeString[39] == '7')
			{
				codeString[39] = '5';
			}
		}
		else if(0 == strncmp("enabled", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '0')
			{
				codeString[39] = '2';
			}
			else if(codeString[39] == '1')
			{
				codeString[39] = '3';
			}
			else if(codeString[39] == '4')
			{
				codeString[39] = '6';
			}
			else if(codeString[39] == '5')
			{
				codeString[39] = '7';
			}
			else if(codeString[39] == '8')
			{
				codeString[39] = 'a';
			}
			else if(codeString[39] == '9')
			{
				codeString[39] = 'b';
			}	
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("LaneAssistWarning", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("disabled", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '3')
			{
				codeString[39] = '2';
			}
			else if(codeString[39] == '7')
			{
				codeString[39] = '6';
			}
			else if(codeString[39] == 'b')
			{
				codeString[39] = 'a';
			}
			else if(codeString[39] == '9')
			{
				codeString[39] = '8';
			}
			else if(codeString[39] == '5')
			{
				codeString[39] = '4';
			}
			else if(codeString[39] == '1')
			{
				codeString[39] = '0';
			}
		}
		else if(0 == strncmp("enabled", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[39] == '0')
			{
				codeString[39] = '1';
			}
			else if(codeString[39] == '2')
			{
				codeString[39] = '3';
			}
			else if(codeString[39] == '4')
			{
				codeString[39] = '5';
			}
			else if(codeString[39] == '6')
			{
				codeString[39] = '7';
			}
			else if(codeString[39] == '8')
			{
				codeString[39] = '9';
			}
			else if(codeString[39] == 'a')
			{
				codeString[39] = 'b';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("FCWP", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == 'b')
			{
				codeString[42] = '3';
			}
			else if(codeString[42] == 'a')
			{
				codeString[42] = '2';
			}
			else if(codeString[42] == '9')
			{
				codeString[42] = '1';
			}
			else if(codeString[42] == '8')
			{
				codeString[42] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == '0')
			{
				codeString[42] = '8';
			}
			else if(codeString[42] == '1')
			{
				codeString[42] = '9';
			}
			else if(codeString[42] == '2')
			{
				codeString[42] = 'a';
			}
			else if(codeString[42] == '3')
			{
				codeString[42] = 'b';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("WarningList", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == 'b')
			{
				codeString[42] = '9';
			}
			else if(codeString[42] == 'a')
			{
				codeString[42] = '8';
			}
			else if(codeString[42] == '3')
			{
				codeString[42] = '1';
			}
			else if(codeString[42] == '2')
			{
				codeString[42] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == '0')
			{
				codeString[42] = '2';
			}
			else if(codeString[42] == '1')
			{
				codeString[42] = '3';
			}
			else if(codeString[42] == '8')
			{
				codeString[42] = 'a';
			}
			else if(codeString[42] == '9')
			{
				codeString[42] = 'b';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("AdvancedPrewarning", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Not_coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == 'b')
			{
				codeString[42] = 'a';
			}
			else if(codeString[42] == '9')
			{
				codeString[42] = '8';
			}
			else if(codeString[42] == '3')
			{
				codeString[42] = '2';
			}
			else if(codeString[42] == '1')
			{
				codeString[42] = '0';
			}
		}
		else if(0 == strncmp("Coded", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[42] == 'a')
			{
				codeString[42] = 'b';
			}
			else if(codeString[42] == '8')
			{
				codeString[42] = '9';
			}
			else if(codeString[42] == '2')
			{
				codeString[42] = '3';
			}
			else if(codeString[42] == '0')
			{
				codeString[42] = '1';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("PrewarningTiming", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("early", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == 'e' || codeString[43] == 'a' || codeString[43] == '6')
			{
				codeString[43] = '2';
			}
			else if(codeString[43] == 'c' || codeString[43] == '8' || codeString[43] == '4')
			{
				codeString[43] = '0';
			}
		}
		else if(0 == strncmp("middle", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == 'e' || codeString[43] == 'a' || codeString[43] == '2')
			{
				codeString[43] = '6';
			}
			else if(codeString[43] == '0' || codeString[43] == '4' || codeString[43] == 'c')
			{
				codeString[43] = '4';
			}
		}
		else if(0 == strncmp("late", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == 'e' || codeString[43] == '6' || codeString[43] == '2')
			{
				codeString[43] = 'a';
			}
			else if(codeString[43] == '0' || codeString[43] == 'c' || codeString[43] == '4')
			{
				codeString[43] = '8';
			}
		}
		else if(0 == strncmp("off", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == 'a' || codeString[43] == '6' || codeString[43] == '2')
			{
				codeString[43] = 'e';
			}
			else if(codeString[43] == '0' || codeString[43] == '4' || codeString[43] == '8')
			{
				codeString[43] = 'c';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("PrewarningDefaultOn", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("default_on", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == '2')
			{
				codeString[43] = '0';
			}
			else if(codeString[43] == '6')
			{
				codeString[43] = '4';
			}
			else if(codeString[43] == 'a')
			{
				codeString[43] = '8';
			}
			else if(codeString[43] == 'e')
			{
				codeString[43] = 'c';
			}
		}
		else if(0 == strncmp("last_mode", CodeByteValue,strlen(CodeByteValue)))
		{
			if(codeString[43] == '0')
			{
				codeString[43] = '2';
			}
			else if(codeString[43] == '4')
			{
				codeString[43] = '6';
			}
			else if(codeString[43] == '8')
			{
				codeString[43] = 'a';
			}
			else if(codeString[43] == 'c')
			{
				codeString[43] = 'e';
			}
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("Headlight", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("Halogen", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[44] = '0';
		}
		else if(0 == strncmp("Xenon", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[44] = '1';
		}
		else if(0 == strncmp("LED", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[44] = '2';
		}
		else if(0 == strncmp("LED_with_variable_light_distribution", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[44] = '3';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("AdditionalHighBeam", CodeByte,strlen(CodeByte)))
	{
		if(0 == strncmp("no_Additional_High_Beam", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[45] = '0';
		}
		else if(0 == strncmp("Halogen", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[45] = '1';
		}
		else if(0 == strncmp("Xenon", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[45] = '2';
		}
		else if(0 == strncmp("LED", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[45] = '3';
		}
		else if(0 == strncmp("Laser", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[45] = '4';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else if(0 == strncmp("LightAssist", CodeByte,strlen(CodeByte)))
	{
		codeString[49] = '0';
		if(0 == strncmp("no_Light_Assist", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[48] = '0';
		}
		else if(0 == strncmp("High_Beam_Assist", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[48] = '2';
		}
		else if(0 == strncmp("Dynamic_Light_Assist", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[48] = '4';
		}
		else if(0 == strncmp("Adaaptive_Headlight_Range_Control", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[48] = '6';
		}
		else if(0 == strncmp("Matrixbeam", CodeByteValue,strlen(CodeByteValue)))
		{
			codeString[48] = '8';
		}
		else
		{
			TestStepFail("INFO","The code value name: '%s' is not valid in '%s' codebyte!", CodeByteValue, CodeByte);
		}
	}
	else
	{
		TestStepFail("INFO","The codebyte name: '%s' is not valid!", CodeByte);
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to read out and store coding parameters.
//!
//! \note 	This must be used prior to CodingModify() testcase!
//- -----------------------------------------------------------------------------------------------
testcase ReadCoding()
{
	RequestResponseCompareLogic("220600", "620600.+", "Regexp");

	codeString[0] = '2';
	codeString[1] = 'e';
	codeString[2] = '0';
	codeString[3] = '6';
	codeString[4] = '0';
	codeString[5] = '0';

	substr_cpy_off(codeString, 6, byteString, 6, -1, elcount(codeString));
	TestStep("INFO","The codestring is: %s", codeString);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to write modified coding parameters into ECU.
//!
//! \note 	ReadCoding() then CodingModify() testcases should be used before this!
//- -----------------------------------------------------------------------------------------------
testcase WriteCoding()
{
	RequestResponseCompareLogic("1003", "5003.+", "Regexp");
	RequestResponseCompareLogic("2ef198010203040506", "6ef198", "Equal");
	RequestResponseCompareLogic("2ef199020202", "6ef199", "Equal");
	RequestResponseCompareLogic(codeString, "6e0600", "Equal");
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase that reads out calibration details, converts them to degrees and evaluates them against a defined tolerance.
//!
//! \note	This function can help calibration testing by converting the measured calibration angles into degrees.
//!			This is VW specific!
//! 		
//! \param  float Tolerance: Calibration has a pre-defined tolerance in the calibration target angles. \n
//!							 By default, this is 2.85°, but can be adapted, if SW changed.
//! \param  int  IsOutOfLimitAllowed: If the test is about to provoke an out of tolerance situation, the function will  \n
//!							 evaluate the measured angles accordingly and fail the test, when all angles are OK.
//! 
//! \note	Valid IsOutOfLimitAllowed can be: \n
//!			- 0: For passed result, all angles should be within tolerance. \n
//!			- 1: For passed result, at least one angle should be out of tolerance. Regardless, which one.
//- -----------------------------------------------------------------------------------------------
testcase ReadCalibDetails(float Tolerance, int IsOutOfLimitAllowed)
{
	//Temporary store for the needed bytes from the response
	char roll[6];
	char pitch[6];
	char yaw[6];
	
	//Calculated degrees
	float rollAngle;
	float pitchAngle;
	float yawAngle;
	
	rollAngle = 0.0;
	pitchAngle = 0.0;
	yawAngle = 0.0;
	
	//Send in the request
	RequestResponseCompareLogic("2209b7","6209b7.*","Regexp");
	
	saveResponse();

	//Extract the needed values in Hex
	roll[0]='0';
	roll[1]='x';
	roll[2]=seedString[6];
	roll[3]=seedString[7];
	roll[4]=seedString[8];
	roll[5]=seedString[9];

	TestStep("INFO", "The roll angle is defined");
	
	pitch[0]='0';
	pitch[1]='x';
	pitch[2]=seedString[10];
	pitch[3]=seedString[11];
	pitch[4]=seedString[12];
	pitch[5]=seedString[13];

	TestStep("INFO", "The pitch angle is defined");
	
	yaw[0]='0';
	yaw[1]='x';
	yaw[2]=seedString[14];
	yaw[3]=seedString[15];
	yaw[4]=seedString[16];
	yaw[5]=seedString[17];

	TestStep("INFO", "The yaw angle is defined");

	//Calculate roll
	rollAngle = (float) atol(roll);

	rollAngle = rollAngle *0.001; //this is how the actual angle is calculated

	rollAngle = rollAngle - 20;

	//Calculate pitch
	pitchAngle = (float) atol(pitch);
	pitchAngle = (pitchAngle *0.001) - 20; //this is how the actual angle is calculated

	//Calculate yaw
	yawAngle = (float) atol(yaw);
	yawAngle = (yawAngle *0.001) - 20; //this is how the actual angle is calculated

	//Evaluate results

	if(IsOutOfLimitAllowed == 0)
	{
	//No out of limit value is tolerated
		if(abs(rollAngle) > Tolerance)
		{
			TestStepFail("INFO","The roll angle is: %f", rollAngle);
		}
		else
		{
			TestStepPass("INFO","The roll angle is: %f", rollAngle);
		}//roll

		if(abs(pitchAngle) > Tolerance)
		{
			TestStepFail("INFO","The pitch angle is: %f", pitchAngle);
		}
		else
		{
			TestStepPass("INFO","The pitch angle is: %f", pitchAngle);
		}//pitch

		if(abs(yawAngle) > Tolerance)
		{
			TestStepFail("INFO","The yaw angle is: %f", yawAngle);
		}
		else
		{
			TestStepPass("INFO","The yaw angle is: %f", yawAngle);
		}//yaw
	}
	else
	{
		//At least one of the angles are out of tolerance?
		if ((abs(rollAngle) > Tolerance) || (abs(pitchAngle) > Tolerance) || (abs(yawAngle) > Tolerance))
		{
			TestStepPass("INFO","There is at least one angle that is out of range");
			TestStep("INFO", "The roll angle is: %f", rollAngle);
			TestStep("INFO", "The pitch angle is: %f", pitchAngle);
			TestStep("INFO", "The yaw angle is: %f", yawAngle);			
		}
		else
		{
			TestStepFail("INFO","All angles are within tolerance");
			TestStep("INFO", "The roll angle is: %f", rollAngle);
			TestStep("INFO", "The pitch angle is: %f", pitchAngle);
			TestStep("INFO", "The yaw angle is: %f", yawAngle);
		}
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to read out the supply voltage measured by the camera.
//!
//! \note	The result may differ (around 100-200mV) from the voltage set on the power supply. 
//- -----------------------------------------------------------------------------------------------
testcase ReadVoltage()
{
	ReadSupplyVoltage();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to read ECU temperature in default session and converts into Celsius degrees.
//!
//!	\note	Offset is considered.
//- -----------------------------------------------------------------------------------------------
testcase ReadTempDefaultSession()
{
	ReadTempDefault();
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Testcase to read out the available temperature values for all ECUs and Imagers.
//!
//! \note	This testcase is available in all platforms. Before calling this testcase, enter into Plant mode and RBEOL.
//!
//!	\param	char type indicates what type of measured temperature value should be read out.
//!
//!	\note	Offset is considered.
//!			\n
//!			Available types:\n
//!			- GenericECU: Returns the average of the ECU temperatures.\n
//!			- GenericImager: Returns the average of the Imager temperatures.\n
//!			- Zync0: Returns the temperature of the Zync0.\n
//!			- Zync1: Returns the temperature of the Zync1.\n
//!			- ImagerA: Returns the temperature of the ImagerA.
//- -----------------------------------------------------------------------------------------------
testcase ReadTempRBEOL(char type[])
{
	ReadTempPlant(type);
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to read out the supply voltage measured by the camera.
//!
//! \note	The result of the function may differ (around 100-200mV) from the voltage set on the power supply. 
//!			Before calling this function, enter into Plant mode and RBEOL.
//!
//! \return	Measured supply voltage in float.
//- -----------------------------------------------------------------------------------------------
float ReadSupplyVoltage()
{
	//Variables
	float v; //The decimal value of the supply voltage will be stored here
	char temp[4]; //This is needed for the response extraction
	
	v=0.0;
	
	if(RequestResponseCompareLogic("224258", "624258.+", "Regexp"))
	{
		saveResponse();
	
		temp[0] = '0';
		temp[1] = 'x';
		temp[2] = seedString[6];
		temp[3] = seedString[7];
	
		//TestStep("INFO", "The measured supply voltage is in hex: %c%c", temp[2],temp[3]);
	
		v = (float) atol(temp);
		v = v *0.1; //this is how the actual voltage value is calculated
	
		TestStep("INFO", "The measured supply voltage is: %f V", v);

		return v;
	}
	else
	{
		return 0;
	}
}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to read ECU temperature in default session and converts into Celsius degrees.
//!
//!	\note	Offset is considered.
//!
//! \return Temperature value in integer.
//- -----------------------------------------------------------------------------------------------
int ReadTempDefault()
{
	//Variables
	int t; //The decimal value of the temperature will be stored here
	char temp[4]; //This is needed for the response extraction
	
	//At this point RBEOL session is assumed
	if(RequestResponseCompareLogic("22028d","62028d.*","Regexp"))
	{
		saveResponse();
		
		//Extract the needed values in Hex (the first two elements of the array are needed for this
		temp[0]='0';
		temp[1]='x';
		temp[2]=seedString[6];
		temp[3]=seedString[7];
	
		//conversion
		t=(int)atol(temp);
	
		//Calculate with -40 offset
		t=t-40;
	
		TestStep("INFO", "The measured ECU temperature is is: %d degC", t);

		return t;
	}
	else
	{
		return 0;
	}
}

testcase fun_test ()
{
	int i;
	for(i=0;i<10;i++)
	{
    RequestResponseCompareLogic("1003", "5003.*", "Regexp");
		RequestResponseCompareLogic("1101", "5101", "Equal");
		TestWaitForTimeout(5000);
	}
}

testcase fun9_test ()
{
	int i;
	for(i=0;i<8;i++)
	{
		RequestResponseCompareLogic("1003", "5003.*", "Regexp");
		RequestResponseCompareLogic("1101", "5101", "Equal");
		TestWaitForTimeout(5000);
	}
}

testcase ignition_cycles_10()
{
int i=0;
for(i=0;i<10;i++)
{

	putvalue(EnvTesterPresentOnOff, 1);
	RequestResponseCompareLogic("1003", "500300320190", "Equal");
    testwaitfortimeout(2000);
	RequestResponseCompareLogic("1101", "5101", "Equal");
	testwaitfortimeout(7000);
	RequestResponseCompareLogic("190209", "5902ffc13187.{1}[8|e|c].*", "Regexp");
	putvalue(EnvTesterPresentOnOff, 0);
}
}

testcase ignition_cycles_9()
{
int i=0;

putvalue(EnvTesterPresentOnOff, 1);
for(i=0;i<9;i++)
{
putvalue(EnvTesterPresentOnOff, 1);
	RequestResponseCompareLogic("1003", "500300320190", "Equal");
    testwaitfortimeout(2000);
	RequestResponseCompareLogic("1101", "5101", "Equal");
	testwaitfortimeout(7000);
	RequestResponseCompareLogic("190209", "5902ffc13187.{1}[8|e|c].*", "Regexp");
	putvalue(EnvTesterPresentOnOff, 0);
putvalue(EnvTesterPresentOnOff, 0);
}

}

//- -----------------------------------------------------------------------------------------------
//! \brief  Function to read out the available temperature values for all ECUs and Imagers.
//!
//! \note	This function is available in all platforms. Before calling this function, enter into Plant mode and RBEOL.
//!
//!	\param	char type indicates what type of measured temperature value should be read out.
//!
//!	\note	Offset is considered.
//!			\n
//!			Available types:\n
//!			- GenericECU: Returns the average of the ECU temperatures.\n
//!			- GenericImager: Returns the average of the Imager temperatures.\n
//!			- Zync0: Returns the temperature of the Zync0.\n
//!			- Zync1: Returns the temperature of the Zync1.\n
//!			- ImagerA: Returns the temperature of the ImagerA.
//!
//! \return Desired temperature value in integer.
//- -----------------------------------------------------------------------------------------------
int ReadTempPlant(char type[])
{
	//Variables
	int t; //The decimal value of the temperature will be stored here
	char tempECU[4]; //This is needed for the response extraction
	char tempImg[4]; //This is needed for the response extraction
	char tempZ0[4]; //This is needed for the response extraction
	char tempZ1[4]; //This is needed for the response extraction
	char tempImgA[4]; //This is needed for the response extraction
	
	//At this point RBEOL session is assumed
	if(RequestResponseCompareLogic("224250","624250.*","Regexp"))
	{
		saveResponse();
	
		if(0 == strncmp("GenericECU", type, strlen(type)))
		{
			tempECU[0]='0';
			tempECU[1]='x';
			tempECU[2]=seedString[8]; //ECU temp
			tempECU[3]=seedString[9];
			
			t=(int)atol(tempECU);
			t=t-128;
			
			TestStep("INFO", "The measured ECU temperature is is: %d degC", t);
		}	
		else if(0 == strncmp("GenericImager", type, strlen(type)))
		{
			tempImg[0]='0';
			tempImg[1]='x';
			tempImg[2]=seedString[12]; //Img temp
			tempImg[3]=seedString[13];
		
			t=(int)atol(tempImg);
			t=t-128;
			
			TestStep("INFO", "The measured Imager temperature is is: %d degC", t);
		}	
		else if(0 == strncmp("Zync0", type, strlen(type)))
		{
			tempZ0[0]='0';
			tempZ0[1]='x';
			tempZ0[2]=seedString[16]; //Z0 ECU
			tempZ0[3]=seedString[17];
			
			t=(int)atol(tempZ0);
			t=t-128;
			
			TestStep("INFO", "The measured Zync0 temperature is is: %d degC", t);
		}	
		else if(0 == strncmp("Zync1", type, strlen(type)))
		{
			tempZ1[0]='0';
			tempZ1[1]='x';
			tempZ1[2]=seedString[20]; //Z1 ECU
			tempZ1[3]=seedString[21];
			
			t=(int)atol(tempZ1);
			t=t-128;
			
			TestStep("INFO", "The measured Zync1 temperature is is: %d degC", t);
		}
		else if(0 == strncmp("ImagerA", type, strlen(type)))
		{
			tempImgA[0]='0';
			tempImgA[1]='x';
			tempImgA[2]=seedString[24]; //Img A
			tempImgA[3]=seedString[25];
			
			t=(int)atol(tempImgA);
			t=t-128;
		
			TestStep("INFO", "The measured Imager A temperature is is: %d degC", t);
		}
		else
		{
			TestStepFail("INFO","The type '%s' is not valid!", type);
		}
		return t;
	}
	else
	{
		return 0;
	}
}